#!/bin/bash

set -euo pipefail

info() { printf "%s\n" "$*" >&2; }
die() { info "!! $*"; exit 1; }

CURRENT_FIRMWARE_TIMESTAMP=1648581622
CURRENT_FIRMWARE_FILE_D21=/usr/share/jupiter_controller_fw_updater/EV2_REL_62435BF6.bin
CURRENT_FIRMWARE_FILE_D20=/usr/share/jupiter_controller_fw_updater/EV2_D20_REL_62435BF6.bin

FIRMWARE_TOOL_TYPE_1=/usr/share/jupiter_controller_fw_updater/d21bootloader16.py
FIRMWARE_TOOL_TYPE_2=/usr/share/jupiter_controller_fw_updater/d20bootloader.py

# Start with this tool -- it will suffice for getting the HW ID which is required
FIRMWARE_TOOL=$FIRMWARE_TOOL_TYPE_1

JQ=jq
checkmode=""

if [[ $# -eq 1 && ${1-} = "--check" ]]; then
  checkmode=1
elif [[ $# -ne 0 ]]; then
  die "Usage: $0 [--check]"
fi

# Enumerate devices
devs=$("$FIRMWARE_TOOL" getdevicesjson) || die "Failed to enumerate devices"
devjq() { $JQ "$@" <<< "$devs"; }

# Is the first device enumerating as a Bootloader?
bootloader=$(devjq '.[0].is_bootloader | select(. != null)')

# If multiple devices, no action if not bootloader (some dev situation w/ multiple controllers?)
# The Type 2 bootloader presents as 2x interfaces, so don't exit if this looks like a bootlaoder
count=$(devjq 'length')
if [[ $count -gt 1 && $bootloader = "false" ]]; then
  info "Multiple devices found, not performing check/update:"
  devjq >&2
  exit 1
elif [[ $count -lt 1 ]]; then
  die "No compatible devices found"
fi

build_timestamp=$(devjq '.[0].build_timestamp | select(. != null)')
secondary_build_timestamp=$(devjq '.[0].secondary_build_timestamp | select(. != null)')

# New Bootloader systems are indicated by major release # of 2 (vs. 1 for older). 
# This is true for both apps and bootloaders which is necessary for this scheme to work.
new_bootloader=false
release_number=$(devjq '.[0].release_number')
major_release=$((release_number>>8))    # Shift to reserve only major version byte

if [[ $major_release -eq 2 ]]; then
  new_bootloader=true
  FIRMWARE_TOOL=$FIRMWARE_TOOL_TYPE_2
fi

devjq >&2

# Now check if we need to update or not.
needupdate=""

if [[ $bootloader = "true" ]]; then
  info "Device is in bootloader mode, update required"
  needupdate=1
elif [[ $build_timestamp -eq 0 ]] || [[ $secondary_build_timestamp -eq 0 ]]; then
    info "Device has missing build timestamp, update required"
    needupdate=1
else
  if [[ ${build_timestamp:-0} -lt $CURRENT_FIRMWARE_TIMESTAMP ]]; then
    info "Device is running build '$build_timestamp', newest $CURRENT_FIRMWARE_TIMESTAMP, update required"
    needupdate=1
  elif [[ ${build_timestamp} -eq $CURRENT_FIRMWARE_TIMESTAMP ]]; then
    info "Device is running latest build $CURRENT_FIRMWARE_TIMESTAMP, update NOT required"
  else
    info "Device is running build '$build_timestamp', newer than available build $CURRENT_FIRMWARE_TIMESTAMP, update NOT required"
  fi
fi


# If no update needed, then done.
if [[ -z $needupdate ]]; then
   exit 0
fi

# If Type 2 BL, we need the HW ID to determine if the secondary controller is D21 or D20
#   For Type 1 bootloader we have all the info we need. Only the orig. D21 / D21 system has that BL
#   Orig D21/D21 system       Type 1 BL, Primary HWID = 27 (provided for reference)
#   Hybrid D21 / D20 system   Type 2 BL, Primary HWID = 30  
#   Homog  D21 / D21 system   Type 2 BL, Primary HWID = 31
hybrid=false
if [[ $new_bootloader = "true" ]]; then
  hwid=$("$FIRMWARE_TOOL" gethwid --clean) || die "Failed to get HW ID"
  info "HWID: ${hwid}"
  if [[ $hwid -eq 30 ]]; then
    hybrid=true
  elif [[ $hwid -eq 31 ]]; then
    hybrid=false
  else 
    die "Type 2 BL found w/ unknown Primary HWID: ${hwid}"
  fi
fi

info "Found candidate device, build timestamp ${build_timestamp:-unknown}, BL $bootloader, BL_Type $major_release, HYB ${hybrid}"


# Done if check mode
if [[ -n $checkmode ]]; then
  info "  --check specified, not performing update"
  if [[ $bootloader = "true" ]]; then
    "$FIRMWARE_TOOL" reset 
  fi
  # status code 7 to determine update-needed in check mode, vs general failure
  exit 7
fi

# Otherwise, perform the udpate.
# Add a handler to stop the updater if we die while it is running
#  (because we can be run as a service, and get SIGTERM'd. The shell does not kill the foreground process in this case.)
unset update_pid

on_error() {
  ret=$?
  if [[ -n ${update_pid-} ]]; then
    info "Interrupted, killing update process $update_pid"
    kill $update_pid
    wait
    info "Update failed, attempting to reset controller..."
    "$FIRMWARE_TOOL" reset || true
  fi
  info "!! Failed to apply firmware update, see above"
  exit $ret
}
trap on_error EXIT

run_firmware_tool() {
  "$FIRMWARE_TOOL" "$@" &
  update_pid=$!
  wait $update_pid
}

# The background+wait is so our exit handler above can kill it if the script itself is asked to stop.  Because bash.
if [[ $new_bootloader = "true" ]]; then

  if [[ $hybrid = "true" ]]; then
    info "Updating Hybrid SECONDARY of Type 2 System"
    run_firmware_tool program --secondary "$CURRENT_FIRMWARE_FILE_D20"
  else 
    info "Updating Homogeneous SECONDARY of Type 2 System"
    run_firmware_tool program --secondary "$CURRENT_FIRMWARE_FILE_D21"
  fi

  info "Updating PRIMARY of Type 2 System"
  run_firmware_tool program --primary "$CURRENT_FIRMWARE_FILE_D21"

else  
  info "Updating Type 1 System"
  run_firmware_tool program "$CURRENT_FIRMWARE_FILE_D21"
fi

info "Firmware updated to $CURRENT_FIRMWARE_TIMESTAMP"
trap - EXIT
